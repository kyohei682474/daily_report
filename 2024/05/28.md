# 2024/05/27の日報
## 取り組んだ課題一覧
* タイピング練習
*  実践 Docker - ソフトウェアエンジニアのDockerよくわからない」を終わりにする本を読む
*  プロを目指す人のためのRuby入門を読む
## わかったこと
*   publicメソッドはクラスの外部からでも自由に呼び出すことができるメソッド。initializeメソッド以外は全てデフォルトでこのメソッドに振り分けられる。
*   privateメソッドは外部からクラス外部からメソッドを呼び出すことができなくなるメソッド。基本的にはprivateより下に定義されたメソッドは外部から呼び出せなくなる。
  *  ただしselfをつければ呼び出すことができる。
*  publicメソッド、 privateメソッドの順番は逆でも構わないが、基本手にはprivateメソッドが後で一度のみ使用する。
*  privateメソッドはサブクラスでも呼び出すことができる。
  *  Rubyで継承を使用する際には意図せぬオーバライドを起こしてしまう可能性が考えられ、不具合の原因にもなるので注意が必要。
*  クラスメソッドを呼び出す際にはクラス名.メソッドにしなくてはいけない。
*  privateメソッドに引数を渡すことができる。引数の受け取り方は他のメソッドと違い:引数とする
*  Rubyのメソッド定義は式になっていて、メソッドの定義が終了するとメソッド名をシンボルとして返す。
*  インスタンスメソッドをクラス内から参照するメソッドをゲッターメソッド。一方でセッターはインスタンス変数の値を更新する役割をする。両方を兼ね備えたものがattr_accesser
*  protectedメソッドは外部には公開したくないが同じクラスやサブクラス内であればレシーバー付きで呼び出せるようにするメソッド。
 *  メソッド定義と同時にprotectedメソッドにすることができる。
* 定数は外部から参照することも可能であり、参照するときの基本構文はクラス名：：定数名
 * 定数はクラス直下で定義するまたはトップレベルで行う。 
 * 外部参照させたくない場合は定数をprivateにする。
* リテラルとはプログラム中に直接記述することができる値。
* Rubyの場合、定数は再代入可能である。これを防ぐためにクラスをfreezeして凍結する必要がある。クラス内でもfreezeを行うことができる。
 * ただしfreezeしてしまうと定数の再代入を防ぐだけでなくメソッドを定義することができなくなるので基本的には行わない。
* ミュータブルなオブジェクトであれば定数の値を変更することができる。イミュータブルなオブジェクトならば破壊的に変更することはできない。
 * ex)0,やシンボル,true、falseなど 
* {}はからのハッシュである。
* ハッシュにキーと値を追加するには "ハッシュ[キー] = 値"
* map.(&:freeze)をmap.{|n| n.feeze}と書き換えることができる。
* インスタンス変数はクラスをオブジェクト化した際にオブジェクトごとに管理される変数。
* クラスインスタンス変数クラスが保持しているデータ。クラス自身のインスタンス変数。
* クラス変数は変数名の最初に@@がつく。クラスメソッド内でもインスタンスメソッド内でも参照することができる。
 * クラス変数内の値が変更されると全てのクラス変数内の値が変わってしまう。
* グローバル変数は$で始まる変数名のこと。
 * 未定義のグローバル変数を参照するとnilが返る
 * 特に特別な理由がない限り使用は避けるべき。
* コードは基本的に誰でもわかるように、理解しやすいコードを書くことが求められる。
* エイリアスメソッドは独自に定義することができる。alias 新しい名前　元の名前
* undefキーワードを使用すると定義を後じゃら削除することができる。
* クラスは入れ子にして再度クラスを入れることができる。クラス内部に定義したクラスを参照するには外部クラス::内部クラスとすることで参照することができる。
 * 名前空間を（ネームスペース）作る場合に使用される。
* スーパークラスのobjectクラスでは==はobject_id（全く同じインスタンス)でなければtrueにならない。 
## 次やること
* タイピング練習
* プロを目指す人のためのRuby入門を読む
## 感じたこと
*  このコードの本質はどこなのか？なぜを追求する回数を増やすことで理解が深まる。
## 学習時間
Today: ３h<br>
Total: 5５１.０h
