# 2024/11/30の日報
## 取り組んだ課題一覧
* タイピング練習
* Ruby on Rails5速習実践ガイドをやる
## わかったこと
* 同期処理はプログラムを１つずつ処理していくプログラミングモデル 
* 非同期処理は前の処理の完了を待たずして次の処理を行うことができる。
  *  同期処理よりも非同期処理の方が短くなる。
*  JavaScriptはシングルスレッドで処理される。つまり１つずつ処理を行い、２つの処理を同時に行うことができない。
  *  javascriptが非同期処理を行うための４つの要素としてはコールスタック、タスクキュー、WebAPI,ヒーブ
  *  コールスタックとは今現在どんな関数が実行されているのか、その関数の中でどの関数が呼び出されているのか？
*  スタックは最後に保存したデータを最初に取り出し、最初に保存したデータは最後に取り出す。
*  last in first out
*  キューは最初に保存したデータを最初に取り出すこと。first in first out
*  タスクキューとは非同期関数の引数に渡された関数はタスクキューに登録されて、コールスタックが空になるまで待機する。
*  WebAIPを使用することによって外部から複雑なアプリケーション簡単に取り入れることができる。
  *  JavaScriptはシングルスレッドで処理するにも関わらず、WebAPIに処理を丸投げするので非同期処理を行うことができる。
  *  WebAPIはsetTimeout関数やsetinterval関数などを使用するので非同期処理を行える。
* setTime関数は指定したm秒後に処理を開始する関数
*  定義した関数を呼び出すには定義した関数名();
*  関数は呼び出されるとスタックに保管され、それが実行されるとスタックから取り出される。
*  WebAPIの関数の例としてはsetTimeout関数、setInterval関数などブラウザが提供するTimerAPIという外部API
*  本番環境で初めてロールバックが失敗するという状況を避けるためにbin/rails db:migrarteでバージョンを上げる際に期待通り動作するか確認する。
*  bin/rails db:migrate:redoで自分が書いたマイグレーションがバージョンを下げる際にトラブルを起こさないことを確認する。
*  マイグレーションにおけるデータベースへの変更はいつも完璧なロールバックができるとは限らない。そこでロールバック(カラムの復活)を行う。ロールバックを禁止する、ロールバックは成功するが、実際には何もしないということが必要。
*  ロールバックを行う際にはカラムを復活させるだけで、データについては何も行わない。
  * 値を指定しないでカラムだけを追加しても支障がない場合。
* カラムを復活させるのに加えて既存のレコードのカラムを仮の値を入れておく。
* バージョンを下げることでActiveRecord：：IrreversibleMigrationエラーをraiseすることでロールバックを禁止する。
  * これによってデータの状態が壊れるということを防ぐことができる。
  * そもそもデータベース状態が壊れるよりは以前のデータベースの状態に戻さないことで防ぐことができる。
* 一人で開発しているのであれば、マイグレーションにカラムが足りないのであれば、気軽に追加をすることができるが、複数人で開発をしている場合は他の開発者が取り込み済みのマイグレーションファイルの内容を勝手に変えてしまうと、後に多くの混乱を発生させてしまう。
* 無闇にロールバックをしてバージョンを下げるよりも新しくマイグレショーンファイルを作る方が良い。
* マイグレーションというのはDBへの変更を複数の開発者がストレスなくシェアすることを目的とする仕組み。
  * マイグレーションは１つ１つ積み重なってできる歴史のようなもの。
  * アプリケーションの運用が始まると障害調査や対応なでデータベースにインデックスを追加するなどの作業を直接行う場合がある。この場合はサーバー上で行なった変更に対応するマイグレーションファイルを確実にローカル環境でも追加するようにする。
* アプリケーションコードはその成長とともに変化してくが、マイグレーションファイルは積み重なっていくものであるのでいつ操作しても一定の作用をデータベースに与えられるように表現しなくてはいけない。
* allメソッドは全てのデータを一度に確保する。よって大量のメモリを確保しようとすることになり、サーバーの動作を不安定にしてしまう。
  * find_eachメソッドはレコードを1000件単位で分割して取得し、ブロック内に記述した処理を繰り返し実行する
  * select句の順番を指定することはできない。常に主キーによる昇順ソートになる。
  * 一度に多くのレコードを操作する場合はfind_eachメソッドを使用する。
* マイグレーションでは処理で例外が発生すれば失敗と見なされてロールバックしてくれる。
  * マイグレーションが失敗した時にロールバックする処理は望ましい作法。
*  updateメソッドでレコードの更新を行ってしまうと失敗した時にfalseを返し、検証失敗などの理由で更新に失敗した場合、例外を発生することはしない。
  * つまりマイグレーションが失敗したとみなされず、ロールバックを行ってくれない。
  * update!を使用して例外を発生させることが重要。
  * 他にもcreate,save,destroyなども必ず例外を発生させるわけではない。
* テーブルのスキーマを毎回データベースに問い合わせることによるパフォーマンス低下を防ぐためにActiveRecordには一度読み込んだテーブルのスキーマをキャッシュする機構が備わっている。
  * ２つ同時に同じテーブルのカラムを更新しようとすると１つ目の更新がキャッシュされて、２つ目の更新時にキャッシュされた情報が更新されずに処理されてしまう。
  * このような場合は手動でキャッシュの更新する必要がある。order_reset_column_infomation
  * テーブルへの変更や追加、削除はスマートキャッシュの影響で反映されない。           
## 感じたこと
* マイグレーションファイルを変更する際にはかなりシビアにならなければいけない。
* まだまだ成長速度が遅いので自分にもっと負荷をかけながらハードに取り組まなければいけない。
## 合計時間  
Today: 3.0h<br>
Total: 944.25h
