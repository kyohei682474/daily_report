# 2024/11/10の日報
## 取り組んだ課題一覧
* タイピング練習
* Ruby on Rails5速習実践ガイドをやる
* ブログ作成
## わかったこと
* rails７以降は非同期処理のturboがデフォルトで使用することができる。
* 通常のマイグレーションは開発環境のみ適応で、テスト環境、本番に適応するにはそれぞれ設定が必要。
  *  テスト環境ではbin/rails db:migrate RAILS_ENV=test
  *  本番環境では bin_rails db_migrate RAILS=ENV=production
*  マイグレーションはバージョンの上げ下げを行うことができる。
  *  rails db:migrateはバージョンを上げる。一方で、rails db:rollbackはバージョンを下げる(tableを削除する際に使用する)
*   change_column_nullの引数にはテーブル名、カラム名,nullを許容するかどうかそれぞれ指定する。
*   データベースカラムの追加や変更の際には一度変更や追加用の雛形ファイルを作成し、変更内容を書き込み、マイグレーションを行う。
*   not null制約が適応されているか確認するにはrails cコンソールを立ち上げ、該当するオブジェクトのnot null制約しているカラムにnilをつけて生成する。
  *  ActiveRecord: :NotNullViolaton例外が適応される。
  *  model作成時にnot nul制約をつける際にはrails g model Task name:string:null:false
  *  データベースではnull同士は常に異なる値であるとみなされる
*  saveメソッドはモデルの検証に使用され、モデルオブジェクトをデータベースに登録、更新する前に検証を行い、エラーがあれば登録、更新を行わず,エラーがなければ登録される。
  *  検証エラーの詳細にはerrorsを通じてアクセスを行う。
  *  予期せぬエラーの場合は例外を発生させる。
  *  登録、更新は行わず、検証のみを単独で行うメソッドはvalid?を使用する。validは妥当であるという意味。
  *  基本的に登録、更新が成功するはずであると確信できている場合はsaveよりもsave!を使用することで予期せぬエラーを防ぐことができる。
*  検証を意図的にスキップするにはvalidate: falseオプションを作成する。例えばtask.save(validate: false)
*  検証ツールを使用するということはmodelファイルにバリデーションを記述するこということ。
*  persisted?はオブジェクがデータベースに保存済みが確認することができるメソッドで保存されていればtrue、保存されていなければfalseを返す。
*  自分で検証するメソッドを追加するステップとして検証用のメソッドをモデルクラスに登録し、検証用メソッドを実装する。
*  &.はボッチ演算子と呼ばれこのメソッドで呼びだされるとレシーバーがnilでもエラーが発生しなくなる。
  * オブジェクトがnilの場合でもエラーを出さずにnilを返す。
* 検証メソッドの基本的な仕事は検証エラーを発見したらerrorにエラー内容を格納する。
  * errors.addの引数にエラー内容を記述することでerrorsにエラー内容を格納している。
  * 中には検証メソッドにも関わらず、登録、更新の際にきちんと検証しないものも存在しているのでデータベースに不正なデータを登録しないためにもきちんと動作する検証用メソッドを使用することが重要。
* 重要な処理の前後に任意の処理を挟むことをコールバックという。
* コールバックのタイミングとしては登録、検証、更新、削除といったメインイベントの前後(before,after)、イベントを挟む(around)の3つのタイミング
* 不正なデータへのアプローチは不正なデータを取り込まないだけでなく、正しいデータに書き換えるというアプローチも存在する。
* before_validationは検証前の値の正規化
* トランザクションは一連の複数の処理によりデータベースの整合性を保つ機能。例えば銀行の入金、出金の処理が片方でも躓いたらロールバックされる仕組み。
* HTTPはステートレスなので状態を保持しないプロトコール。
* セッションとは1つブラウザから連続して送られている一連のリクエストの状態を共有する仕組み。
  * アプリケーションサーバー側で独自に実現される仕組み。 
  * コントローラからsessionというメソッドを呼び出すことでセッションにアクセスすることができる。
  * sessionはハッシュのよに扱うことができる。
  * セッションにデータを格納するに任意のキーを指定して値を格納する。
  * session[:user_id] = @user.id
  * 値を取り出すには@user_id = session[user_id]とする。
* cookieはブラウザとWebサーバー間のやり取りされる、より汎用的な仕組み
  * 複数のリクエストの間で共有したい状態をブラウザ側に保存する仕組み。
  * railsのセッションの仕組みがcookieによって実現される。
  * ブラウザ側で対応するcookieのデータを削除すれば、セッションはリセットされる。
* digestは元の値にもどうすことができない、一方的な変換(ハッシュ化)を行った文字列のこと。無意味に見える文字列となる。
  * 変換を行った後のパスワードならばそれが外部に盛れたとしてもパスワードは盗むことにはならない。
* カラムの一意性はdb/migrateに存在するfileに記述する。
* has_secure_passwordはデータベースにパスワードを保存するときに盗まれても大丈夫なように無意味な文字列(文字列のハッシュ化)にして保存する仕組み。
  * passwordをハッシュかするためにbcryptというハッシュ関数を提供するgemが必要になる。
  * has_secure_passwordを使用するにはuserモデルでhas_secure_passwordを記述する。
* has_secure_passwordを記述するとデータベースのカラムに対応しない属性が2つ追加され、1つ目はpassword,2つ目はpassword_confirmation
  * passwordはユーザが入力した生のパスワードを一時的に保存しておくための属性。
  * password_cofirmationは確認用のパスワードを一時的に保存する属性
  * passwordとpassword_cofirmationが一致して初めてログインができるようになる。
* アプケーションのuserの管理を行う際には未登録ユーザが自らサインアップしを行う方法と、管理者がユーザを登録することでユーザーがアプリケーションを利用できるようにする2つの方法がある。
* bin/rails g controller Admin::Users new edit show indexのAdmin::はネームスペースとして利用されるモジュールの中にUserControllerというクラスを定義する
  * controllersディレクトリ内にadminディレクトリが作成されてそこにuser_controllerが作成される。   
  * adminディレクトリの下にまとまってコードが作成される。
  * user_controllerにはnew,edit,show,indexアクションが存在している。                    
## 感じたこと
* 流れは大体把握しているのだが、いざ一人で実装となるとかなり苦労するだろうなと感じている。しかしとにかく頭と手を動かして実装あるのみ。
* まだまだ実際の現場で働けるようなエンジニアではないと感じているのでとにかく学習時間を増やして辛抱強く学習を継続していくしかない。
## 合計時間  
Today: 4.5h<br>
Total: 882.75h
