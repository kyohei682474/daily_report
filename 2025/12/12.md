# 2025/12/12の日報
## 取り組んだ課題一覧
* タイピング練習
## わかったこと 
* プリミティブ値の検索はindexofを使用する
* オブジェクトの検索はfindIndexを使用する
* Reactにおけるpushは破壊的メソッド。つまり元の配列を壊してしまう
  * 似たようなメソッドで非破壊的メソッドはconcatというメソッド
* Reactの参照比較は===で行う。
* Reactは破壊的メソッドだとuseStateなどの状態管理でうまく感知できず、値が仮に更新されていたとしても更新されたことに気がつくことができなくなってしまう
* reduceは減らす以外にもたたみ込むという意味がある。つまり、複数の値を１つに畳み込んで値を表示するという意味につながる
* メソッドチェーンは複数のメソッドを連結させて複雑な処理を簡潔に書ける。
  * 例えばfilterやmapをメソッドチェーンを使用して(連続てメソッドを使用することによってfiletrとmapを使用する)どちらの処理の行った状態にする。
* useStateは分割代入を使用していて[値,更新関数]とした分割代入を入れている
  * const [count, setCount] = useState(0)
* spread構文は非破壊的に新しい配列を作成することができるので、ReactのuseStateのような状態管理でよく使用することができる。
* オブジェクトはプロパティの集まりであり、プロパティはキーと値の組み合わせで成り立つもの
* 配列は同じデータの集合体だが、プロパティは異なる種類のデータをまとめる
* 分割代入とはオブジェクトから特定のプロパティを取り出して変数にする構文
* カスタムフックはアロー関数を用いてオブジェクトを返す。
* 通常の関数宣言であればホイスティングが行われる。一方でアロー関数ではホイスティングが起きない
  * ホイスティングは宣言がスコープの先頭に巻き上げられることを意味する。
* constは変数の再代入は禁止しているが、変数さ参照している値の中身の変更は禁止されていない
* Reactでは状態を直接変更しようとすると同じ参照なので変化を察知することができない。だから値の変更を行う際には新たにオブジェクトを作成してそれを使用してsetStateなどの関数に渡すことによって値の変更を察知させる
* プロパティの上書きを行うには後から書いたものを優先して上書きしていく。
  * ある変数があり、オブジェクトを生成しているとする。その変数のプロパティの値を上書きするために違う変数を宣言して上書きしたいプロパティのキーと上書きしたい値を記述してオブジェクトを作成する
  * また新たに変数を宣言してそこにspread構文を使用して変数に代入する。するとそこには上書きされたオブジェクトが生成される。
* 浅いコピーであればあるネストされているオブジェクトをコピーしたときに大元のオブジェクトは別の参照先を示しているのですが、ネストされているオブジェクトに関しては同じ参照先を示している
* 内部のオブジェクトもコピーする場合は内部のオブジェクトを展開してからコピーする必要がある。
  * 内部のオブジェクトも新しいオブジェクトとして作りたい場合は内部のオブジェクトをスプレッド構文で展開する必要がある。
* Mapはキーと値の組み合わせからなるビルトインオブジェクトであり、抽象データ型。
* 配列は順番が大事になってくるので順番に値を取り出したい時などに使用する。MapはIDで直接値にアクセスしたいときに、高速処理を行うことができる。
  * 配列のオブジェクトからid検索をしてその値を取り出す場合は最初から全て値を探して、該当するidを見つけて取り出すことを行う。よって処理が遅くなる
  * Mapの場合は検索をかけたidから直接それの値を取り出すことができるので処理が早くなる
  * ハッシュテーブルを使用しているのでMapは高速でしてする値を見つけ出すことができる。
* Setはセット型のコレクションを扱うためのビルトインオブジェクト
  * 重複を許さない配列のようなオブジェクトで、順序を持たないのでインデックスによるアクセスはできない
  * Mapオブジェクトと同様にSetオブジェクトもnewすることで新しいオブジェクトを作成することができる。
* メソッドとプロパティの違いについてはメソッドには()がつき、puropatexiniha()がつかない
* オブジェクトのキーは文字列に変わってしまう
  * Mapはオブジェクトそのものをキーにすることができる
* Reactが画面を更新するステップとして３つあり、トリガーとレンダーとコミットの３つ
  * トリガーには２つあり、初回のレンダリングとstateの更新時のレンダリング
  * レンダーはJSXを生成する。レンダー=コンポーネント関数を呼び出すこと
    * レンダーはDOMをまだ触っていなくこの次はこうなるべきと言う設計図(仮想DOM)
  * コミットでは実際にDOMを触っていく。レンダーの時の仮想DOMと現在の画面を比較して実際に差異がある部分のみDOMに反映させる
* Reactコンポーネントはマークアップを返すJavascript関数
  * 関数名は大文字から始めることによってHTMLタグという区別がつく
* JSXはjavascriptの窓でJavascriptを含めることができる
* propsは親からこの渡すデータ。
  * 親しか知り得ないデータを子に渡すことによって親のデータを使用することができる。
  * propsにはデフォルト値を設定することができ、その値が渡されなければ自動でデフォルトの値が返ってくる。
    * 例えばfunction GoalItem({ title, completed = false})とするとPropsからcompletedが返ってこないとすると自動でcompleted = falseが返るようになる
* 親子の関係は２種類ありPropsの親子関係とUIの親子関係がある
*　 
    
            
     

## 次やること
* 
##  合計時間 
Today: 2.0h<br>
Total: 1873.05
