# 2025/05/25の日報
## 取り組んだ課題一覧
* タイピング練習
* twitterクローンの課題
* Every day Rspecを読む
## わかったこと 
* entryモデルはチャット参加者の情報を管理しているモデル。
  * userとroomのidが格納されている。
  * 参加者一覧が表示される。
  * ユーザーが明示的にオブジェクトを作成しなければcreateルーティングを作成する必要はない。
  * 逆の削除に関しても同じことが言える。
* chatはroomにネストすることでroomに関連付けながらchatのルーティングを行うことができる。
  *  UIも直感的でわかりやすくなる。
  *  ルーティングやビューで直感的になる。
  *  フォームもシンプルになる
  *  リソースの親子関係が責務に影響を与える
  *  RESTの原則から子のリソースは親をリソースとして表現されるべき
  *  また該当するRESTの原則はリソースは一意に識別可能であるべき、リソースは関連URLを作成すべき、リソースの構造は文脈を持つべき
  *  ネストしていい条件は親と子に明確な従属関係がある、子のリソースの取得、削除するには親のリソースを作成、削除しなくてはいけない、子リソース単体では曖昧で意味をなさない
*  粒度が粗いと意味が曖昧になりがち。逆に細かいとネストが深くなりすぎて複雑になる。
*  room#showはチャットの内容を表示するために必要なアクション
*  recipient = User.find(params[:user_id])はチャット相手を取得するためのコード
  * ユーザーのツイートの右上に存在するdoropdownボタンからダイレクトメッセージをクリックした際にそのユーザーを取得するためのコマンド
*  Roomjoins(:entries)はinner joinを行っている。
  *  ON entries.room_id = rooms.idと同じことをしている。
  *  roomとentryは1:Nの関係である。
*  where(entries: { user_id: [current_user.id, recipient.id] })ではcurrent_userとrecipientのidであるようなentriesを持つroomに絞り込む
*  .group("rooms.id")はrooms.id毎にグループ化するという意味
*  havingはグループ化した後にさらに条件を絞り込む。
  * 集計の結果を扱う場合はhavingを使用する。
*  思考順：ユーザー行動 → ドメイン → エンティティ → URL設計 → コントローラ → ビュー
*  実装手順: モデル → ルーティング → コントローラ → ビュー → UI調整           

## 感じたこと
* コードの単純な表現だけでなく、そのコードや仕組みの概念まで理解使用することがギークなエンジニアを目指す上で大切になる。
* いきなり完璧なコードを書こうとするのではなく、エラーが起きない程度に簡単なコードを記述して徐々に完成度の高いコードを記述していく癖をつける
## 次やること
* twitterクローンの課題
* Every day Rspecを読む
##  合計時間 
Today: 4.0h<br>
Total: 1431.05h
