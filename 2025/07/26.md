# 2025/07/26の日報
## 取り組んだ課題一覧
* タイピング練習
* JavaScript Primerを読む
## わかったこと 
* try{}catch{}finally{}を使用することで例外処理を行うことができる。
  * try節にエラーが起こりそうな文を記述。
  * 例外が発生するとtry節は中断されてcatch節へ移動する。
  * catch節では発生したエラーオブジェクトを引数として受け取り、例外処理を行う。
  * finallyは例外関係なく処理を記述する
  * catch節またはfinally節のどちらか片方あればどちらかを省略することができる。
  * 但し、例外発生時にcatch節が存在しないと例外はスルーされてしまい、finally節実行後に例外が発生する。
* throw文を使用するとユーザーがエラーを投げることができる。
  * エラーオブジェクトにエラーを格納してそれをcatch節で捕獲することができる。
  * thorwできるものはエラーオブジェクトでなくても良いが、スタックトレースのためにエラーオブジェクトを投げることが推奨される。
* Errorオブジェクトとはnew Errorでインスタンスを生成する。第一引数にはエラーメッセージとなる文字列を挿入する。
* ReferenceErrorは存在しない変数や関数などの識別子を参照しようとするとエラーになる。
  * 参照先でエラーになっているのでconsole.log()内で問題がある可能性があることを示している。
  * 未定義の識別子(変数や関数)を参照しようとしたときに生じるエラー
* SyntaxErrorは構文的に不正なコードを解釈しようとしたときに生じるエラー
  * javascriptを実行する前のパース段階で起こるエラー。
  * 実行前に起きるSyntaxErrorは例外処理のcatchでエラーを捕獲することができない。
  * 構文の記述の仕方が間違っている場合に起こるエラー
* TypeErrorは期待されている型でないときに生じるエラー。
  * 関数でない値を関数として呼び出そうとするときに生じる
  * 定義はされているが型として不適切な操作を行おうとするとき
* console.errorを出力するとスタックトレースも出力するのでデバッグしやすくなる。
  * errorに引数にキャッチしたエラーを渡すことができる。
* エラーをキャッチしてさらに投げることをすることで新しいエラーメッセージを投げることができるが、これでは本来のスタックトレースが失われてしまう。
  * これを回避するために、エラーコンストラクタの第二引数にcause: errorを追加することで、スタックトレースの追跡性を保ったまま新しいエラーを返すことができる。
  * Error自体はコンストラクタ関数であり、new Errorとすることでエラーオブジェクトのインスタンスを生成することになる。
* 同期処理は処理が上から行われ、1つの処理が終わるまで次の処理を実行することはしない。
* 非同期処理は基本上から順番に行われるが、待機時間のあるような処理は後回しにして、次の処理を行う。
  * setTimeout関数はdelayms後にコールバック関数をタイマーに登録すると非同期処理を行う。
  * setTimeout(コールバック関数, delay);
  * コールバック関数は関数自体を渡すので合って、呼び出してはいけない。
  * アロー関数を使用しても良い。アロー関数を使用するときは引数も渡したいときに有効。
* メインスレッドとはあらゆる処理の主要な一本線の道路みたいなもの。
  * 同期処理も非同期処理も同じメインスレッド上で処理を行なっているのでお互いに影響を受けて処理を行う。ただし非道処理の待機時間のみはメインスレッドをブロックしない。
* 並行処理は処理を一定の単位ごとに分割して交互に処理することであたかも同時に処理しているように見せかける仕組み
  * 非同期処理の前に重たい処理があると非同期処理も実行が遅くなってしまう現象が起こる
* 並列処理はメインスレッドとは別のスレッドやCPUを使用して処理を物理的に同時並行に行う仕組みのこと
* 同期処理は例外処理を行うことができる。しかし非同期処理は例外処理を行うことができない。
  * try..catchは同期処理においての例外をキャッチすることができる仕組みであり、非同期処理であるsetTimeoutで例外が起きても外側のtry..catchではキャッチできない。
  * try...catchのスコープ外で例外が発生するから
  * もし非同期処理でも例外をキャッチするには非同期で個別にtry..catchを使用する。
* promiseインスタンスは状態や結果を表現し、その結果に応じて呼び出されるコールバック関数を登録する
  * 非同期処理をPromiseで扱う場合、promiseインスタンスは非同期の完了結果を表現し、状態変化に応じて呼び出されるコールバック関数を登録できる 
## 感じたこと
* 
## 次やること
* JavaScript Primerを読む
##  合計時間 
Today: 4.0h<br>
Total: 1637.05h
