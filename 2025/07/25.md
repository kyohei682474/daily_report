# 2025/07/24の日報
## 取り組んだ課題一覧
* タイピング練習
* JavaScript Primerを読む
## わかったこと 
* 静的クラスフィールドはフィールドの前にstaticを使用するだけでそのプロパティはクラス自体のプロパティで定義されている。
  * 呼び出す際はクラス名.プロパティ名
* 静的クラスフィールドはプライベート名の前にstaticというキーワードを記述することでクラスをインスタンス化しなくても直接プロパティを呼び出すことができる
* 静的プライベートクラスフィールドはクラス外からアクセスできないクラスフィールド
  * ＃の前にstaticというキーワードを記述することによってインスタンス化しなくてもクラス内からアクセスできる。
* インスタンスメソッドは() =>{}つまりアロー関数で定義されて、thisが固定されている。thisのバインドが必要な場合やコールバックに渡す場合などに使用される。
* プロトタイプメソッドはプロトタイプに共有されて、全てのインスタンスで同じ関数を使い回すことができる。
* インスタンスメソッドを定義するとインスタンスオブジェクトへ定義される。
* プロトタイプメソッドを定義するとプロトタイプオブジェクトへ定義される。
  * クラスや関数が定義されると自動でプロトタイプが生成される。その中に自動でプロトタイプオブジェクトが生成され、格納される。
  * クラスも一種の関数オブジェクトだから自動でプロトタイプオブジェクトが生成される。
  * クラスの内部にはcunstroctor関数として定義されている。だからクラスは一種の関数であり、オブジェクトになる。
  * 関数＝オブジェクト
* インスタンスからプロトタイプオブジェクトを呼び出せるのはプロトタイプチェーンという仕組みがあるから。
  * インスタンス生成時に内部プロパティである[[Prototype]にそのクラスや関数のプロトタイプオブジェクトが自動的に参照として設定される処理。
  * 参照を保存するとは繋がりを持たせるということ。
  * インスタンスからプロパティを参照する際に、インスタンスの内部プロパティである[[Prototype]まで探してきて見つけ出す処理
* [[Prototype]]は継承元のをなす、共通のリンクのようなもので異なるインスタンスでも同じ[[Prototype]]を共有していればそこに記述されているメソッドを使用することができる。
* 
## 感じたこと
* 
## 次やること
* JavaScript Primerを読む
##  合計時間 
Today: 7.0h<br>
Total: 1631.05h
