# 2025/09/12の日報
## 取り組んだ課題一覧
* タイピング練習
* ガチで学びたい人のためのJavaScriptメカニズム
## わかったこと 
* ダイナミックインポートはimport {"モジュールのパス"}でモジュールを非同期で読み込む仕組み
  *  戻り値はpromiseなので非同期処理を行なっていることがわかる。
  *  動的importは必要な時だけimportを行う。
  *  promiseなのでAsync、awaitを使用して非同期処理を行うことができる。
  * 初期時には不要なコードを後から読み込むことができるので画面表示を高速化することができる。
* オブジェクトリテラルとは{}を使用してオブジェクトを作成すること
* Proxyオブジェクトはプロパティの操作を制御、監視するための仕組み
* 基本的なProxyの後部としてはconst proxy = new Proxy(target, handler);と記述する。
  * targetには元になるオブジェクト、handlerには操作をトラップするためのメソッド群
  * 主なトラップはget,set,deleteがある。何かオブジェクトのプロパティに変更があった際に使用されるメソッドであることからトラップと呼ばれる
* レシーバーはトラップに返ってくる実際のProxyオブジェクトそのもの。呼び出し元のオブジェクトが入る。proxyのオブジェクトがreceiverとなる
* reflectはjavascriptエンジンに使用する内部メソッドにアクセスする関数を提供する。
* Reflectの主な手段としては内部メソッドとしての統一的な手段として使用する。
  *  newは内部的にはReflect.construct。new演算子を使用しなくてもオブジェクトを作成することができる。内部的には[[construct]]という内部メソッドが呼び出されている。
  *  Reflect.constructは [[construct]]を直接呼び出すことができるAPI。つまりnewとほぼ同じと言える
  *  第一引数にはオブジェクトで第二引数にはオブジェクトに渡したい引数を渡す。
* inは内部的にはReflect.has
  * Reflect.has(’オブジェクト', 該当するプロパティ) 
  *  obj[prop]にはReflect.get
  *  関数として扱えるのでコールバック関数や高級関数に使用する際には直接こちらのReflectを使用することができる
  *  newは演算子なのでcallback(new)などと使用することができない。
* Proxy内のトラップ実装内でReflectを呼ぶと自然に振る舞いを補完することができる。
* Objectメソッドは失敗時にはエラーを返すがReflecctメソッドは失敗時にはfalseを返す。よってエラーハンドリングが簡単。
  * ifを使用することでtrueの時の挙動とfalseの時の挙動を簡単に記述することができる。
  * Objcectはtry..catchを使用しないければエラーハンドリングを行うことができない
  * promise関数のエラーハンドリングはthen.とcatchを使用して行う。
* 静的メソッドはインスタンス化を行わずににメソッド化を行うことができる。
* ProxyもReflectも同じ名前のメソッドを持っていてついになっているので,Proxyのtrap内でReflectを使用することで挙動変えずに実行できかつ、元の動作をそのまま拡張することができる。
*     
 
## 感じたこと
* 
## 次やること
* ガチで学びたい人のためのJavaScriptメカニズム
##  合計時間 
Today: 4.0h<br>
Total: 1773.55
